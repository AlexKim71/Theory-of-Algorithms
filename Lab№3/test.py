# Глобальні лічильники для трасування
global_swaps = 0
global_compares = 0

def swap(arr, i, j):
    """Міняє місцями два елементи в масиві та інкрементує лічильник обмінів."""
    global global_swaps
    arr[i], arr[j] = arr[j], arr[i]
    global_swaps += 1

def sink(arr, i, n):
    """
    Процедура 'занурення' елемента вниз по купі з підрахунком порівнянь.
    """
    global global_compares
    k = i
    while True:
        j = 2 * k + 1  # Індекс лівого дочірнього елемента
        
        # Перевірка, чи існує лівий дочірній елемент
        if j >= n:
            # global_compares += 1 # Порівняння j >= n
            break
        
        # Знаходимо індекс найбільшого дочірнього елемента
        # Порівняння 1: j + 1 < n
        # Порівняння 2: arr[j + 1] > arr[j]
        global_compares += 2 
        if j + 1 < n and arr[j + 1] > arr[j]:
            j += 1

        # Якщо поточний елемент більший або дорівнює найбільшому дочірньому
        # Порівняння 3: arr[k] >= arr[j]
        global_compares += 1
        if arr[k] >= arr[j]:
            break
        
        # Міняємо місцями та продовжуємо занурення
        swap(arr, k, j)
        k = j

def heapsort(arr):
    """
    Алгоритм пірамідального сортування.
    """
    global global_swaps, global_compares
    # Скидаємо лічильники для нового запуску
    global_swaps = 0
    global_compares = 0
    
    n = len(arr)
    print(f"Початковий масив: {arr}\n")
    
    # --- Фаза 1: Побудова максимальної купи ---
    print("--- Фаза 1: Побудова максимальної купи ---") 
    for i in range(n // 2 - 1, -1, -1):
        # Примітка: Я залишаю вивід трасування згідно з оригінальним запитом
        # print(f"Занурюємо елемент з індексу {i}: {arr[i]}")
        sink(arr, i, n)
    
    print(f"\nМасив після побудови купи: {arr}\n")
    
    # --- Фаза 2: Сортування ---
    print("--- Фаза 2: Сортування ---")
    
    current_n = n
    for i in range(n - 1, 0, -1):
        
        # Обмін корінь-кінець (один Swap)
        swap(arr, 0, i)
        
        # Зменшуємо розмір купи та відновлюємо її властивості
        current_n -= 1
        sink(arr, 0, current_n)
    
    print("---")
    print(f"Відсортований масив: {arr}")
    print("\n--- Загальна кількість операцій ---")
    print(f"Обміни: {global_swaps}")
    print(f"Порівняння: {global_compares}")
    print("-----------------------------------")
    
    return arr

# --- Моделювання з вашими даними ---
A = [84, 64, 37, 92, 2, 98, 5, 35, 70, 52, 73, 51, 88, 47]
sorted_A = heapsort(A)
